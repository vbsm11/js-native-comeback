// eventloop

console.log('a')

setTimeout(() => {
    console.log('timeout')
}, 1000)

console.log('b')

console.log('c')
// порядок срабатывания - 'a', 'b', 'c', 'timeout'
// a, b, c работают по принципу 'последний пришел первый ушел', но в данном случае срабатывают и уходят сразу (так же принцип называется stack, lifo)
// все асинхронное, в том числе setTimeOut, попадает в очередь и срабатывает только после того, как освободился stack (очередь - queue)
// даже если бы в setTimeOut timeOut был бы 0, console.log в нем все равно бы сработал последним, так как все асинхронные операции в js (колбэки, запросы на сервер) после выполнения с помощью web apis отправляются в очередь, а уже из этой очереди в stack вызова



console.log('a')

setTimeout(() => {
    console.log('timeout1')
}, 1000)

setTimeout(() => {
    console.log('timeout2')
}, 0)

console.log('b')
// порядок срабатывания - 'a', 'b', 'timeout2', 'timeout1'



setTimeout(() => {
    console.log('timeout1')
}, 1000)

setTimeout(() => {
    console.log('timeout2')
}, 1000)

setTimeout(() => {
    console.log('timeout3')
}, 1000)
// порядок срабатывания - 'timeout1', 'timeout2', 'timeout3'
// порядок сохраняется, т.к они отправляются на web apis по порядку с разницей в долю секунды

// существует три основные очереди - macrotasks, rendering и microtasks
// между macrotasks и rendering рендерингу отдается приоритет, задачи из этой очереди выполняются в первую очередь


// микротаски - это промисы
// eventloop будет выполнять очередь с микротасками первой, пока они не закончатся (даже если в процессе выполнения она будет пополняться новыми микротасками)
// за тем будет идти очередь rendering (там в отличие от микротасок пополнение очереди во время выполнения других тасок не приводит к продолжению выполнения этой очереди)

// eventloop обращается к этим очередям только когда стек вызова пуст